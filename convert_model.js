#!/usr/bin/env node
/**
 * Script para convertir SavedModel a TF.js usando @tensorflow/tfjs-converter
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

const SAVED_MODEL = path.join(__dirname, 'dist/models/student_v1_fp16_manual/saved_model');
const OUTPUT_DIR = path.join(__dirname, 'dist/models/student_v1_fp16');

console.log('=========================================');
console.log('Conversión SavedModel → TF.js');
console.log('=========================================\n');

// Verificar que existe SavedModel
if (!fs.existsSync(SAVED_MODEL)) {
    console.error(`ERROR: SavedModel no encontrado en ${SAVED_MODEL}`);
    process.exit(1);
}

console.log(`✓ SavedModel encontrado: ${SAVED_MODEL}\n`);

// Limpiar output dir si existe
if (fs.existsSync(OUTPUT_DIR)) {
    console.log('Limpiando directorio de salida...');
    fs.rmSync(OUTPUT_DIR, { recursive: true, force: true });
}

fs.mkdirSync(OUTPUT_DIR, { recursive: true });

// Ejecutar conversión usando el CLI del paquete instalado
console.log('Ejecutando tensorflowjs_converter...');
console.log(`  Input:  ${SAVED_MODEL}`);
console.log(`  Output: ${OUTPUT_DIR}`);
console.log(`  Quantization: float16\n`);

const converterPath = path.join(__dirname, 'node_modules', '@tensorflow', 'tfjs-converter', 'dist', 'converter.js');

if (!fs.existsSync(converterPath)) {
    console.error('ERROR: Convertidor no encontrado. Ejecuta: npm install @tensorflow/tfjs-converter');
    process.exit(1);
}

try {
    execSync(`node "${converterPath}" \
        --input_format=tf_saved_model \
        --output_format=tfjs_graph_model \
        --quantize_float16="*" \
        "${SAVED_MODEL}" \
        "${OUTPUT_DIR}"`, {
        stdio: 'inherit',
        shell: true
    });
} catch (error) {
    console.error('\nERROR durante la conversión:', error.message);
    process.exit(1);
}

console.log('\n=========================================');
console.log('✓ Conversión completada exitosamente');
console.log('=========================================\n');

// Mostrar archivos generados
console.log('Archivos generados:');
const files = fs.readdirSync(OUTPUT_DIR);
files.forEach(file => {
    const filePath = path.join(OUTPUT_DIR, file);
    const stats = fs.statSync(filePath);
    const sizeKB = (stats.size / 1024).toFixed(2);
    console.log(`  ${file} (${sizeKB} KB)`);
});

// Calcular tamaño total
const totalSize = execSync(`du -sh "${OUTPUT_DIR}"`, { encoding: 'utf-8' }).split('\t')[0];
console.log(`\nTamaño total del modelo: ${totalSize}`);

// Copiar metadata
const metadataSource = path.join(__dirname, 'dist/models/student_v1_fp16_manual/export_metadata.json');
const metadataDest = path.join(OUTPUT_DIR, 'export_metadata.json');

if (fs.existsSync(metadataSource)) {
    fs.copyFileSync(metadataSource, metadataDest);
    console.log('\n✓ export_metadata.json copiado');

    // Actualizar metadata con rutas TF.js
    const metadata = JSON.parse(fs.readFileSync(metadataDest, 'utf-8'));
    metadata.export_pipeline.tfjs_model = "dist/models/student_v1_fp16/model.json";
    metadata.export_pipeline.tfjs_conversion_method = "Node.js @tensorflow/tfjs-converter";
    fs.writeFileSync(metadataDest, JSON.stringify(metadata, null, 2));
    console.log('✓ Metadata actualizado con rutas TF.js');
}

console.log('\n=========================================');
console.log('Verificación del modelo');
console.log('=========================================\n');

// Verificar model.json
const modelJsonPath = path.join(OUTPUT_DIR, 'model.json');
if (fs.existsSync(modelJsonPath)) {
    console.log('✓ model.json generado correctamente\n');

    const modelJson = JSON.parse(fs.readFileSync(modelJsonPath, 'utf-8'));
    console.log(`Model format: ${modelJson.format || 'unknown'}`);
    console.log(`Generated by: ${modelJson.generatedBy || 'unknown'}`);

    // Contar shards
    const shards = files.filter(f => f.endsWith('.bin'));
    console.log(`\nShards generados: ${shards.length}`);
    if (shards.length > 0) {
        console.log('\nDetalles de shards:');
        shards.forEach(shard => {
            const shardPath = path.join(OUTPUT_DIR, shard);
            const stats = fs.statSync(shardPath);
            const sizeMB = (stats.size / (1024 * 1024)).toFixed(2);
            console.log(`  ${shard}: ${sizeMB} MB`);
        });
    }
} else {
    console.error('ERROR: model.json no fue generado');
    process.exit(1);
}

console.log('\n=========================================');
console.log('Siguiente paso:');
console.log('=========================================\n');
console.log('1. Verifica model.json en:', modelJsonPath);
console.log('2. Copia el directorio completo a aplantidaFront/public/models/');
console.log(`   cp -r ${OUTPUT_DIR} /ruta/a/aplantidaFront/public/models/student_v1.0\n`);
console.log('3. Actualiza PlantRecognition/index.js:');
console.log('   const CONFIDENCE_THRESHOLD = 0.62;');
console.log("   const MODEL_URLS = { 'v1.0': '/models/student_v1.0/model.json' };\n");
console.log('4. Actualiza Service Worker para precachear:');
console.log('   - /models/student_v1.0/model.json');
console.log('   - /models/student_v1.0/group1-shard*.bin\n');
console.log('5. Test en navegador:');
console.log("   const model = await tf.loadGraphModel('/models/student_v1.0/model.json');\n");
